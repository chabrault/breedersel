# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Run the application
run_app()
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
#' Run the Shiny Application
#'
#' @param ... arguments to pass to golem_opts.
#' See `?golem::get_golem_options` for more details.
#' @inheritParams shiny::shinyApp
#'
#' @export
#' @importFrom shiny shinyApp
#' @importFrom golem with_golem_options
run_app <- function(
onStart = NULL,
options = list(),
enableBookmarking = NULL,
uiPattern = "/",
...
) {
golem::with_golem_options(
app = shiny::shinyApp(
ui = app_ui,
server = app_server,
onStart = onStart,
options = options,
enableBookmarking = enableBookmarking,
uiPattern = uiPattern
),
golem_opts = list(...)
)
}
run_app()
source("~/work/grapesel/R/app_config.R", echo=TRUE)
run_app()
# Building a Prod-Ready, Robust Shiny Application.
#
# README: each step of the dev files is optional, and you don't have to
# fill every dev scripts before getting started.
# 01_start.R should be filled at start.
# 02_dev.R should be used to keep track of your development during the project.
# 03_deploy.R should be used once you need to deploy your app.
#
#
######################################
#### CURRENT FILE: DEPLOY SCRIPT #####
######################################
# Test your app
## Run checks ----
## Check the package before sending to prod
devtools::check()
rhub::check_for_cran()
# Deploy
## Local, CRAN or Package Manager ----
## This will build a tar.gz that can be installed locally,
## sent to CRAN, or to a package manager
devtools::build()
## Docker ----
## If you want to deploy via a generic Dockerfile
golem::add_dockerfile_with_renv()
yes
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
help("esquisse-deprecated")
#' Run the Shiny Application
#'
#' @param ... arguments to pass to golem_opts.
#' See `?golem::get_golem_options` for more details.
#' @inheritParams shiny::shinyApp
#'
#' @export
#' @importFrom shiny shinyApp
#' @importFrom golem with_golem_options
run_app <- function(
onStart = NULL,
options = list(),
enableBookmarking = NULL,
uiPattern = "/",
...
) {
golem::with_golem_options(
app = shiny::shinyApp(
ui = app_ui,
server = app_server,
onStart = onStart,
options = options,
enableBookmarking = enableBookmarking,
uiPattern = uiPattern
),
golem_opts = list(...)
)
}
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
source("~/work/grapesel/R/app_server.R", echo = TRUE)
# Run the application
run_app()
source("~/work/grapesel/R/app_ui.R", echo = TRUE)
# Run the application
run_app()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
source("~/work/grapesel/R/mod_import_table.R", echo = TRUE)
source("~/work/grapesel/R/app_server.R", echo = TRUE)
# Building a Prod-Ready, Robust Shiny Application.
#
# README: each step of the dev files is optional, and you don't have to
# fill every dev scripts before getting started.
# 01_start.R should be filled at start.
# 02_dev.R should be used to keep track of your development during the project.
# 03_deploy.R should be used once you need to deploy your app.
#
#
######################################
#### CURRENT FILE: DEPLOY SCRIPT #####
######################################
# Test your app
## Run checks ----
## Check the package before sending to prod
devtools::check()
rhub::check_for_cran()
# Deploy
## Local, CRAN or Package Manager ----
## This will build a tar.gz that can be installed locally,
## sent to CRAN, or to a package manager
devtools::build()
## Docker ----
## If you want to deploy via a generic Dockerfile
golem::add_dockerfile_with_renv()
## If you want to deploy to ShinyProxy
golem::add_dockerfile_with_renv_shinyproxy()
## Posit ----
## If you want to deploy on Posit related platforms
golem::add_positconnect_file()
golem::add_shinyappsio_file()
golem::add_shinyserver_file()
## Deploy to Posit Connect or ShinyApps.io ----
## Add/update manifest file (optional; for Git backed deployment on Posit )
rsconnect::writeManifest()
pkgload::load_all(export_all = FALSE,helpers = FALSE,attach_testthat = FALSE)
options( "golem.app.prod" = TRUE)
grapesel::run_app() # add parameters here (if any)
golem::run_app()
golem::run_dev()
library(datamods)
datamods::import_modal(
id = "test_modal",
from = c("file", "copypaste"),
size = "xl",
title = "Data import"
)
remotes::install_github("dreamRs/datamods")
remotes::install_github("dreamRs/datamods")
datamods::import_modal()
golem::run_dev()
library(shiny)
library(datamods)
ui <- fluidPage(
actionButton("launch_modal", "Launch import"),
datamods::import_ui("import_modal"),
verbatimTextOutput("data_name")
)
server <- function(input, output, session) {
observeEvent(input$launch_modal, {
datamods::import_modal("import_modal")
})
imported <- datamods::import_server("import_modal")
output$data_name <- renderPrint({
req(imported$name())
imported$name()
})
}
shinyApp(ui, server)
remotes::install_github("RinteRface/bs4Dash")
library(shiny)
library(datamods)
ui <- fluidPage(
tags$h3("Import data with copy & paste"),
fluidRow(
column(
width = 4,
import_copypaste_ui("myid")
),
column(
width = 8,
tags$b("Imported data:"),
verbatimTextOutput(outputId = "status"),
verbatimTextOutput(outputId = "data")
)
)
)
server <- function(input, output, session) {
imported <- import_copypaste_server("myid")
output$status <- renderPrint({
imported$status()
})
output$data <- renderPrint({
imported$data()
})
}
shinyApp(ui, server)
golem::run_dev()
golem::run_dev()
?bs4DashPage
golem::run_dev()
golem::run_app().
golem::run_app()
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
shiny::runApp()
install.packages("shinyWidgets")
install.packages("bs4Dash")
install.packages("shinyWidgets")
shiny::runApp()
shiny::runApp()
?datamods::import_modal
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
?mgidi
shiny::runApp()
shiny::runApp()
shiny::runApp()
? tidyr::pivot_longer
? tidyr::pivot_longer
shiny::runApp()
shiny::runApp()
shiny::runApp()
debugSource("~/work/grapesel/R/fct_helpers.R", echo = TRUE)
debugSource("~/work/grapesel/R/fct_helpers.R", echo = TRUE)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
?metan::mgidi
shiny::runApp()
traceback()
shiny::runApp()
devtools::install_github("TiagoOlivoto/metan", build_vignettes = TRUE)
devtools::install_github("TiagoOlivoto/metan")
pak::pkg_install("TiagoOlivoto/metan")
shiny::runApp()
getwd()
library(readr)
table_PlosOne_Laucou2018mod <- read_csv("C:/Users/cbrault/Downloads/table_PlosOne_Laucou2018mod.csv")
View(table_PlosOne_Laucou2018mod)
tab <- read_csv("C:/Users/cbrault/Downloads/table_PlosOne_Laucou2018mod.csv")
tab
dat.sub <- tab |> select(genotype,veraison,maturity)
dat.sub <- tab |> dplyr::select(genotype,veraison,maturity)
ideotype <- c(veraison="h",maturity="h")
metan::mgidi(.data=dat.sub, use_data="pheno", ideotype=ideotype)
mg <- calc_mgidi(data=dat.sub, vmore=c("veraison","maturity"))
source("~/work/grapesel/R/fct_helpers.R", echo = TRUE)
library(metan)
mg <- calc_mgidi(data=dat.sub, vmore=c("veraison","maturity"))
mg <- calc_mgidi(data=dat.sub, var_more=c("veraison","maturity"))
mg
var_more=c("veraison","maturity")
vmore=c("veraison","maturity")
dt_long <- data %>% dplyr::select(all_of(c("genotype",vmore, vless))) %>%
tidyr::pivot_longer(cols=c(vmore, vless),
names_to="name",values_to="value")
vless <- NULL
data
data=dat.sub
vmore=c("veraison","maturity")
vless <- NULL
dt_long <- data %>% dplyr::select(all_of(c("genotype",vmore, vless))) %>%
tidyr::pivot_longer(cols=c(vmore, vless),
names_to="name",values_to="value")
## group and average trait values by genotype
dt_mean_long <- dt_long %>%
dplyr::group_by(genotype,name) %>%
dplyr::summarise(Mean=mean(value, na.rm=TRUE))
## re-set at wide format
dt_mean_wide <- dt_mean_long %>%
tidyr::pivot_wider(values_from=Mean) %>%
as.data.frame()
dt_mean_wide
if(avg_NA){
dt_mean_wide[,c(vmore,vless)] <- apply(dt_mean_wide[,c(vmore,vless)],2,
function(x){
tidyr::replace_na(x, replace=mean(x, na.rm=TRUE))
}
)
}
avg_NA=TRUE
if(avg_NA){
dt_mean_wide[,c(vmore,vless)] <- apply(dt_mean_wide[,c(vmore,vless)],2,
function(x){
tidyr::replace_na(x, replace=mean(x, na.rm=TRUE))
}
)
}
## set rownames to genotype
#rownames(dt_mean_wide) <- dt_mean_wide$genotype
dt_mean_wide <- dt_mean_wide[,c("genotype",vmore,vless),drop=FALSE]
dat_mgidi <- na.omit(dt_mean_wide)
print(head(dat_mgidi))
ideotype=c(rep("h",length(var_more)),
rep("l",length(var_less)))
var_less <- NULL
ideotype=c(rep("h",length(var_more)),
rep("l",length(var_less)))
if(is.null(weights)) weights <- rep(1,length(ideotype))
res_mgidi <- metan::mgidi(.data=dat_mgidi,
use_data="pheno",
SI=SI, # selection intensity
mineval=mineval, # value for number of factors retained
ideotype=ideotype[colnames(dat_mgidi)[-1]],
weights=weights[colnames(dat_mgidi)[-1]],
use="pairwise.complete.obs", verbose=FALSE)
res_mgidi <- metan::mgidi(.data=dat_mgidi,
use_data="pheno",
SI=15, # selection intensity
mineval=mineval, # value for number of factors retained
ideotype=ideotype[colnames(dat_mgidi)[-1]],
weights=weights[colnames(dat_mgidi)[-1]],
use="pairwise.complete.obs", verbose=FALSE)
colnames(dat_mgidi)
colnames(dat_mgidi)[-1]
colnames(dat_mgidi)[-1]
weights
length(ideotype)
if(is.null(weights)) weights <- rep(1,length(ideotype))
weights
weights <- rep(1,length(ideotype))
res_mgidi <- metan::mgidi(.data=dat_mgidi,
use_data="pheno",
SI=15, # selection intensity
mineval=mineval, # value for number of factors retained
ideotype=ideotype[colnames(dat_mgidi)[-1]],
weights=weights[colnames(dat_mgidi)[-1]],
use="pairwise.complete.obs", verbose=FALSE)
shiny::runApp()
shiny::runApp()
shiny::runApp()
golem::add_resource_path("www", app_sys("app/www"))
library(golem)
library(shiny)
golem::add_resource_path("www", app_sys("app/www"))
?app_sys
?app_sys
shiny::runApp()
# Set options here
options(golem.app.prod = FALSE) # TRUE = production mode, FALSE = development mode
# Comment this if you don't want the app to be served on a random port
options(shiny.port = httpuv::randomPort())
# Detach all loaded packages and clean your environment
golem::detach_all_attached()
# rm(list=ls(all.names = TRUE))
# Document and reload your package
golem::document_and_reload()
# Run the application
run_app()
# Building a Prod-Ready, Robust Shiny Application.
#
# README: each step of the dev files is optional, and you don't have to
# fill every dev scripts before getting started.
# 01_start.R should be filled at start.
# 02_dev.R should be used to keep track of your development during the project.
# 03_deploy.R should be used once you need to deploy your app.
#
#
######################################
#### CURRENT FILE: DEPLOY SCRIPT #####
######################################
# Test your app
## Run checks ----
## Check the package before sending to prod
devtools::check()
rhub::check_for_cran()
# Deploy
## Local, CRAN or Package Manager ----
## This will build a tar.gz that can be installed locally,
## sent to CRAN, or to a package manager
devtools::build()
## Docker ----
## If you want to deploy via a generic Dockerfile
golem::add_dockerfile_with_renv()
## If you want to deploy to ShinyProxy
golem::add_dockerfile_with_renv_shinyproxy()
## Posit ----
## If you want to deploy on Posit related platforms
golem::add_positconnect_file()
golem::add_shinyappsio_file()
golem::add_shinyserver_file()
## Deploy to Posit Connect or ShinyApps.io ----
## Add/update manifest file (optional; for Git backed deployment on Posit )
rsconnect::writeManifest()
# To deploy, run: rsconnect::deployApp()
# Or use the blue button on top of this file
pkgload::load_all(export_all = FALSE,helpers = FALSE,attach_testthat = FALSE)
options( "golem.app.prod" = TRUE)
grapesel::run_app() # add parameters here (if any)
# To deploy, run: rsconnect::deployApp()
# Or use the blue button on top of this file
pkgload::load_all(export_all = FALSE,helpers = FALSE,attach_testthat = FALSE)
options( "golem.app.prod" = TRUE)
grapesel::run_app() # add parameters here (if any)
shiny::runApp()
shiny::runApp()
shiny::runApp()
?i18n
## initialize translation
# Load translations and set default language
i18n <- datamods::i18n$new(
translation_csv = "www/translations.csv",
language = "en"
)
library(datamods)
i18n(x, translations = i18n_translations())
i18n("Browse", translations = i18n_translations())
set_i18n("fr")
i18n("Browse", translations = i18n_translations())
i18n_translations
?i18n
i18n_translations(package = packageName(parent.frame(2)))
i18n_translations(package = packageName("grapesel"))
library(grapesel)
i18n_translations(package = packageName("grapesel"))
i18n_translations(package = "grapesel")
i18n("Browse...", translations = i18n_translations("datamods"))
